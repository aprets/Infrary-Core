import os
import sys
import json
import random
import string
import pytest
import mock
import sys
from mock import MagicMock

sys.modules['google'] = MagicMock()
sys.modules['google.appengine'] = MagicMock()
sys.modules['google.appengine.ext'] = MagicMock()

ROOT_PATH = os.path.dirname(__file__)
sys.path.append(os.path.join(ROOT_PATH, '..'))


def pytest_addoption(parser):
    parser.addoption('--quick', '-Q', dest="quick", action='store_true', help='disables autogenerated tests')


@pytest.fixture
def app():
    import api
    api.app.debug = True
    return api.app


# noinspection PyUnusedLocal,SpellCheckingInspection
@pytest.fixture
def auth_headers():
    # Dynamically get the token (slow [has to confirm pw with db on every test]):

    # response = client.post(url_for('login'), data = '{"email":"d","password":"c"}', content_type='application/json')
    # assert 200 == response.status_code
    # return {'Authorization': 'Bearer ' + response.get_data(), 'Content-Type': 'application/json'}

    # Use static, everlasting token (dangerous[ish] {Since it is a fake user with no rights, real data}):

    # noinspection SpellCheckingInspection
    return {'Authorization': 'Bearer ' +
                             "eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJ0cGsxMTAwQGdtYWlsLmNvbSJ9"
                             ".RdaktaImzS1dQY3J6XM8F_FR1i8akmLozm1zcoctUr_A3iMW23NYe_mEVjL1rDhlcQXIQaFGH0W6jixXl"
                             "-Cm10jFaQAXeC83z5MuJdgnba7Omr20jLe0bB9LvgyBoLUlRI1ZcPDrShrZg2oqHg33st3Xhhgq8bJfJOB"
                             "CoGDh3U2mYSxpPOnmWNfqZyOJfa99mWkiQvSoKIuq8PwtLOXTV5SvP0WbFX_2mmptEstB0Os606bwOaaBn"
                             "habymYDdlPlDlGG5a0qO0IooaLB-jzFjONquczTEAQ3oshDG1Xd7yb35l_2Scbmk5VreYi5Q0hx3VOehZH"
                             "Ttvtq9XZL_K5bOg",
            'Content-Type': 'application/json'}


@pytest.fixture
def app():
    import api
    api.app.testing = True
    api.app.config['SERVER_NAME'] = 'localhost'
    ctx = api.app.app_context()
    ctx.push()
    return api.app.test_client()


# def test_form(app):
#     r = app.get('/form')
#     assert r.status_code == 200
#     assert 'Submit a form' in r.data.decode('utf-8')
#
#
# def test_submitted_form(app):
#     r = app.post('/submitted', data={
#         'name': 'Inigo Montoya',
#         'email': 'inigo@example.com',
#         'site_url': 'http://example.com',
#         'comments': ''})
#     assert r.status_code == 200
#     assert 'Inigo Montoya' in r.data.decode('utf-8')


def get_int():
    return random.randint(-3665, 3665)


def get_float():
    return random.uniform(-3665, 3665)


def get_string():
    return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(random.randint(1, 8)))


def get_everything_but_not_empty_string_list():
    return [get_int(), get_float(), "", 0, 0.0, {}, []]


def get_everything_but_int_list():
    return [get_string(), get_float(), "", 0.0, {}, []]


def get_everything_but_float_list():
    return [get_int(), get_string(), "", 0, {}, []]


def get_everything_but_list_list():
    return [get_int(), get_float(), get_string(), "", 0, 0.0, {}]


def get_everything_but_dict_list():
    return [get_int(), get_float(), get_string(), "", 0, 0.0, []]


def gen_test_dict_list(input_dict):
    # A bit more sane code follows, do keep enabled
    # Generates a list of test dicts with invalid input subbed for one of the values
    # and all the other values left valid.
    # Gens ~100+ tests

    test_list = []
    for key, value in input_dict.items():
        for testValue in value[0]:
            test_dict = {}
            orig_dict = input_dict.copy()
            del orig_dict[key]
            for untestedKey, untestedValue in orig_dict.items():
                test_dict[untestedKey] = untestedValue[1]
            test_dict[key] = testValue
            test_list.append(test_dict)
    return test_list

    # Insane code follows, DO NOT ENABLE
    # Runs through ALL possible invalid dict combinations
    # This is mostly pointless IRL, but gives much better certainty in invalid input rejection
    # THIS WILL GENERATE 90,000+ TESTS
    # adding more invalid input variations on large dicts WILL crash pytest
    #
    # import itertools as it
    #
    # variants= {}
    #
    # for key, value in inputDict.items():
    #     variants[key] = value[0]
    #
    # # The following code is magic, please do not touch
    # varNames = sorted(variants)
    # combinations = [dict(zip(varNames, prod)) for prod in it.product(*(variants[varName] for varName in varNames))]
    # return combinations


print gen_test_dict_list({"__Infrary__ID": [get_everything_but_int_list(), 52352353],
                          "__Infrary__Provider": [get_everything_but_not_empty_string_list(), "DO"]})


def autogen_tests(tup):
    tup_list = []
    for element in gen_test_dict_list(tup[0]):
        tup_list.append((json.dumps(element),) + tup[1:])
    return tup_list


def autogen_tests_raw(tup):
    tup_list = []
    for element in gen_test_dict_list(tup[0]):
        tup_list.append((element,) + tup[1:])
    return tup_list
